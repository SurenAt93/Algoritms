// Այս մոդուլում ներկայացված են ալգորիթմներ Ֆիբոնաչիի հաջորդականության n-րդ անդամը հաշվելու համար

// 1. Ֆիբոնաչիի n-րդ անդամը հաշվելու ռեկուրսիվ  դասական ձև

function fib(n) {
  if (n === 0 || n === 1) {
    return n;
  } else {
    return fib(n - 1) + fib(n - 2);
  }
}

// 2. Նույնը ավելի կարճ տարբերակով

function fib(n) {
  if (n < 2) return n;
  return fib(n - 1) + fib(n - 2);
}

// 3. Նույնը տերնար գործողության միջոցով

function fib(n) {
  (n < 2)? n: fib(n - 1) + fib(n - 2);
}

// 4. Առանց մեմոնիզացիա նման դասական լուծումը հիմնված ռեկուրսիայի վրա
//    ալգորիթմի բարդության տեսանկյունից օպտիմալ չէ։ n-ը 50֊ի դեպքում
//    ֆունկցիայի կանչերի քանակը մոտ 40000000000 է։
//    Օպտիմիզացիա մեմոնիզացիայի միջոցով
//    Այս դեպքում ֆունկցիայի կանչերի քանակը n-ի դեպքում n+1 է։

const fibs = {};

function fib(n) {
  if (n < 2) {
    return n;
  } else {
    if (!((n - 1) in fibs)) {
      fibs[n - 1] = fib(n - 1);
    }
    if (!((n - 2) in fibs)) {
      fibs[n - 2] = fib(n -2);
    }
    return fibs[n - 1] + fibs[n - 2];
  }
}

// 5. Ֆիբոնաչիի հաջորդականության n-րդ անդամի հաշվումը ցիկլի միջոցով

var a = 0;
var b = 1; // it is a current number

for(let i = 0; i < n - 1; i++) {
  b = a + b;
  a = b - a;
}
